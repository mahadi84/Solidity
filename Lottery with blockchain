
01. Who will conduct the lottery?
02. How to identify the participated players and count them?
03. How much money must pay every player to participate the lottery?
04. How to receive the money from Players?
05. How to select the winner automatically?
06. How to and who will transfer the total money to the winner's account?


--------------------------------------------------------------------

//SPDX-License-Identifier: GPL-3.0 
pragma solidity >=0.5.0 <0.9.0;
 
contract Lottery{
    
    // declaring the state variables
    address payable[] public players; //dynamic array of type address payable
    address public manager; 
    
    constructor(){
        // initializing the owner to the address that deploys the contract
        manager = msg.sender; 
    }
    
    // declaring the receive() function that is necessary to receive ETH
    receive () payable external{
        // each player sends exactly 0.1 ETH 
        require(msg.value == 0.1 ether);
        // appending the player to the players array
        players.push(payable(msg.sender));
    }
    
    // returning the contract's balance in wei
    function getBalance() public view returns(uint){
        // only the manager is allowed to call it
        require(msg.sender == manager);
        return address(this).balance;
    }
    
    // helper function that returns a big random integer
    function random() internal view returns(uint){
       return uint(keccak256(abi.encodePacked(block.difficulty, block.timestamp, players.length)));
    }
    
    // selecting the winner
    function pickWinner() public{
        // only the manager can pick a winner if there are at least 3 players in the lottery
        require(msg.sender == manager);
        require (players.length >= 3);
        
        uint r = random();
        address payable winner;
        
        // computing a random index of the array
        uint index = r % players.length;
    
        winner = players[index]; // this is the winner
        
        // transferring the entire contract's balance to the winner
        winner.transfer(getBalance());
        
        // resetting the lottery for the next round
        players = new address payable[](0);
    }
 
}


-----

### এই কোডটি কী ব্যাখ্যা করে?

এই সলিডিটি চুক্তিটি একটি সহজ লটারি সিস্টেম তৈরি করে। 
এখানে একজন 'ম্যানেজার' চুক্তিটি স্থাপন করেন এবং খেলোয়াড়রা (players) ইথার পাঠিয়ে লটারিতে অংশ নেয়। 
ম্যানেজার স্বয়ংক্রিয়ভাবে একজন বিজয়ী নির্বাচন করতে পারেন এবং বিজয়ীকে চুক্তির সমস্ত ইথার স্থানান্তর করা হয়। 
একটি রাউন্ড শেষ হওয়ার পর লটারি আবার নতুন করে শুরু হয়।

-----

### ০১. লটারি কে পরিচালনা করবে?

লটারিটি চুক্তি স্থাপনকারী (deployer) দ্বারা পরিচালিত হবে, যাকে এখানে 'ম্যানেজার' (manager) বলা হয়েছে।

কোডের এই অংশটি এটি নিশ্চিত করে:
address public manager; 
// ...
constructor(){
    // initializing the owner to the address that deploys the contract
    manager = msg.sender; 
}
```

এখানে `constructor()` ফাংশনটি চুক্তিটি ব্লকচেইনে স্থাপন করার সময় একবারই এক্সিকিউট হয়। `manager = msg.sender;` লাইনটি নিশ্চিত করে যে, যে ঠিকানা থেকে চুক্তিটি স্থাপন করা হচ্ছে, সেই ঠিকানাই `manager` হিসেবে সেট হবে।

-----

### ০২. অংশগ্রহণকারী খেলোয়াড়দের কীভাবে চিহ্নিত করা হবে এবং তাদের সংখ্যা কীভাবে গণনা করা হবে?

  * শনাক্তকরণ: অংশগ্রহণকারী খেলোয়াড়দের একটি ডাইনামিক অ্যারেতে (`players`) তাদের ঠিকানা (`address payable`) হিসাবে সংরক্ষণ করা হয়। যখন একজন খেলোয়াড় লটারিতে অর্থ পাঠায়, তখন তার ঠিকানা এই অ্যারেতে যুক্ত হয়।
    address payable[] public players; //dynamic array of type address payable
    // ...
    receive () payable external{
        // ...
        players.push(payable(msg.sender)); // প্রেরকের ঠিকানা players অ্যারেতে যোগ করা হচ্ছে
    }
    ```
  * গণনা: `players` অ্যারের দৈর্ঘ্য (`players.length`) দেখে অংশগ্রহণকারী খেলোয়াড়দের সংখ্যা গণনা করা হয়।

-----

### ০৩. লটারিতে অংশ নিতে প্রতিটি খেলোয়াড়কে কত টাকা দিতে হবে?

লটারিতে অংশ নিতে প্রতিটি খেলোয়াড়কে ঠিক ০.১ ইথার (ETH) দিতে হবে।

`receive()` ফাংশনের এই লাইনটি এটি নিশ্চিত করে:
receive () payable external{
    // each player sends exactly 0.1 ETH 
    require(msg.value == 0.1 ether);
    // ...
}
```

`require(msg.value == 0.1 ether);` লাইনটি পরীক্ষা করে যে, প্রেরিত অর্থের পরিমাণ ঠিক ০.১ ইথার কিনা। যদি এর কম বা বেশি হয়, তাহলে লেনদেনটি ব্যর্থ হবে এবং রিভার্ট হয়ে যাবে।

-----

### ০৪. খেলোয়াড়দের কাছ থেকে অর্থ কীভাবে গ্রহণ করা হবে?

খেলোয়াড়দের কাছ থেকে অর্থ একটি বিশেষ `receive()` ফাংশনের মাধ্যমে গ্রহণ করা হয়।
receive () payable external{
    // each player sends exactly 0.1 ETH 
    require(msg.value == 0.1 ether);
    // appending the player to the players array
    players.push(payable(msg.sender));
}
```

যখন কোনো ঠিকানা এই চুক্তিতে ইথার পাঠায় (কোনো নির্দিষ্ট ফাংশন কল না করে), তখন স্বয়ংক্রিয়ভাবে এই `receive()` ফাংশনটি এক্সিকিউট হয়। এই ফাংশনটি নিশ্চিত করে যে সঠিক পরিমাণ ইথার পাঠানো হয়েছে এবং তারপর প্রেরকের ঠিকানা (`msg.sender`) `players` অ্যারেতে যোগ করা হয়।

-----

### ০৫. বিজয়ী স্বয়ংক্রিয়ভাবে কীভাবে নির্বাচিত হবে?

বিজয়ী স্বয়ংক্রিয়ভাবে `random()` ফাংশন এবং `pickWinner()` ফাংশন ব্যবহার করে নির্বাচিত হয়।

  * র‍্যান্ডম সংখ্যা তৈরি:

    function random() internal view returns(uint){
       return uint(keccak256(abi.encodePacked(block.difficulty, block.timestamp, players.length)));
    }
    ```

    `random()` ফাংশনটি একটি ছদ্ম-র‍্যান্ডম সংখ্যা তৈরি করে। এটি `keccak256` হ্যাশিং অ্যালগরিদম ব্যবহার করে `block.difficulty` (ব্লকের জটিলতা), `block.timestamp` (ব্লকের টাইমস্ট্যাম্প) 
এবং `players.length` (খেলোয়াড়ের সংখ্যা) এর মতো ডেটা একত্রিত করে একটি হ্যাশ তৈরি করে। এই হ্যাশটিকে একটি আনসাইনড ইন্টিজারে রূপান্তর করা হয়। 
যদিও এটি পুরোপুরি র‍্যান্ডম নয় (ব্লক মাইনারদের দ্বারা প্রভাবিত হতে পারে), এটি একটি লটারির জন্য যথেষ্ট।

  * বিজয়ী নির্বাচন:

    function pickWinner() public{
        // ...
        uint r = random(); // একটি র‍্যান্ডম সংখ্যা তৈরি করুন
        // ...
        uint index = r % players.length; // র‍্যান্ডম সংখ্যাকে খেলোয়াড়ের সংখ্যা দিয়ে মডুলো করে একটি ইনডেক্স তৈরি করুন

        winner = players[index]; // এই ইনডেক্সের খেলোয়াড়ই বিজয়ী
        // ...
    }
    ```

    `pickWinner()` ফাংশনে, `random()` ফাংশন থেকে প্রাপ্ত সংখ্যাটিকে `players` অ্যারের দৈর্ঘ্য দিয়ে মডুলো (`%`) করা হয়। এর ফলে `0` থেকে `players.length - 1` এর মধ্যে একটি ইনডেক্স পাওয়া যায়। 
এই ইনডেক্স ব্যবহার করে `players` অ্যারে থেকে একজন খেলোয়াড়কে বিজয়ী হিসেবে নির্বাচন করা হয়।

-----

### ০৬. মোট টাকা বিজয়ীর অ্যাকাউন্টে কে এবং কীভাবে স্থানান্তর করবে?

ম্যানেজার (manager) `pickWinner()` ফাংশন কল করার মাধ্যমে মোট টাকা বিজয়ীর অ্যাকাউন্টে স্থানান্তর করবেন।
function pickWinner() public{
    // only the manager can pick a winner if there are at least 3 players in the lottery
    require(msg.sender == manager); // ম্যানেজার ছাড়া অন্য কেউ এই ফাংশন কল করতে পারবে না
    require (players.length >= 3); // কমপক্ষে 3 জন খেলোয়াড় থাকতে হবে
    
    // ... (বিজয়ী নির্বাচন) ...
    
    // transferring the entire contract's balance to the winner
    winner.transfer(getBalance()); // বিজয়ীর অ্যাকাউন্টে চুক্তির সমস্ত ব্যালেন্স স্থানান্তর করা হচ্ছে
    
    // resetting the lottery for the next round
    players = new address payable[](0); // লটারি নতুন রাউন্ডের জন্য রিসেট করা হচ্ছে
}
```

  * `require(msg.sender == manager);` লাইনটি নিশ্চিত করে যে শুধুমাত্র চুক্তিটির ম্যানেজারই `pickWinner()` ফাংশনটি কল করতে পারবেন।
  * `winner.transfer(getBalance());` লাইনটি নির্বাচিত বিজয়ীর ঠিকানায় (`winner`) চুক্তির বর্তমান সমস্ত ব্যালেন্স (`getBalance()` ফাংশন থেকে প্রাপ্ত) স্থানান্তর করে।
  * টাকা স্থানান্তরের পর, `players = new address payable[](0);` লাইনটি `players` অ্যারেটিকে খালি করে দেয়, যাতে পরবর্তী লটারি রাউন্ডের জন্য চুক্তিটি প্রস্তুত হয়।









-
