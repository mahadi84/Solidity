
তারিখ: ১১ জুন ২০২৪

০০. সলিডিটি কী?
০১. সলিডিটিতে কত প্রকার ডেটা টাইপ আছে? তাদের মধ্যে পার্থক্য কী কী?
০২. ভেরিয়েবল কত প্রকারের হয়? স্টেট, লোকাল এবং গ্লোবাল ভেরিয়েবলের মধ্যে পার্থক্য/সুবিধা কী কী? লোকাল ভেরিয়েবলের ডেটা কোথায় জমা হয়?
০৩. ভিজিবিলিটি প্রাইভেট, পাবলিক এবং ইন্টারনাল কী?

০৪. অ্যারে কী এবং এটি কিভাবে কাজ করে? অ্যারে পুশ কিভাবে সংজ্ঞায়িত করা হয়?
০৫. IF...ELSE স্টেটমেন্ট কিভাবে কাজ করে? টেনারি অপারেটর কিভাবে সংজ্ঞায়িত করা হয়?
০৬. লুপ: FOR

০৭. CONSTRUCT() কিভাবে সংজ্ঞায়িত করা হয়?
০৮. একাধিক মান কিভাবে ফেরত দেওয়া হয়?
০৯. রিকোয়ার, রিভার্ট এবং অ্যাসার্ট এর মধ্যে পার্থক্য কী?

১০. সলিডিটিতে `view` এবং `pure` এর মধ্যে পার্থক্য কী?

-----

### ০১. সলিডিটিতে কত প্রকার ডেটা টাইপ আছে? তাদের মধ্যে পার্থক্য কী কী?

সলিডিটিতে মূলত দুই প্রকারের ডেটা টাইপ আছে:

১. ভ্যালু টাইপস (VALUE TYPES):
এগুলো তাদের ডেটা সরাসরি নিজেদের মেমরিতে সংরক্ষণ করে। এর মানে হলো, যখন একটি ভ্যালু টাইপ ভেরিয়েবল একটি ফাংশন আর্গুমেন্ট বা অ্যাসাইনমেন্টে ব্যবহৃত হয়, তখন ভেরিয়েবলের একটি কপি তৈরি হয়। সলিডিটিতে আটটি মৌলিক ভ্যালু টাইপ আছে:

  * int (সাইনড ইন্টিজার): এগুলি ধনাত্মক এবং ঋণাত্মক উভয় পূর্ণসংখ্যা সংরক্ষণ করতে পারে (যেমন: `int8`, `int256`)। `int256` (ডিফল্ট) ৩২ বাইট ডেটা সংরক্ষণ করে এবং এর রেঞ্জ $-২^{২৫৫}$ থেকে $২^{২৫৫}-১$ পর্যন্ত।
  * uint (আনসাইনড ইন্টিজার): এগুলি শুধুমাত্র অ-ঋণাত্মক পূর্ণসংখ্যা (০ সহ) সংরক্ষণ করতে পারে (যেমন: `uint8`, `uint256`)। `uint256` $০$ থেকে $(২^{২৫৬} - ১)$ পর্যন্ত মান ধারণ করতে পারে, যা একটি খুব বড় সংখ্যা (দশমিকে প্রায় $১.১৫৭৯ \\times ১০^{৭৭}$)।
  * bool (বুলিয়ান): এগুলি শুধুমাত্র `true` বা `false` হতে পারে (যেমন: $০$ বা $১$)।
  * address (অ্যাড্রেস): এগুলি একটি ২০-বাইটের ইথেরিয়াম অ্যাড্রেসকে প্রতিনিধিত্ব করে (ইথার পাঠানো ও গ্রহণ, অন্যান্য চুক্তির সাথে ইন্টারঅ্যাকশন, অ্যাকাউন্টের তথ্য সংরক্ষণে ব্যবহৃত হয়)।
      * অ্যাড্রেস কেস-সেনসিটিভ (যেমন: `0xAbCdEf1234567890AbCdEf1234567890` এবং `0xabcdEf1234567890aBcDeF1234567890` ভিন্ন)।
      * সলিডিটিতে দুটি অ্যাড্রেস টাইপ আছে:
          * `address`: ব্যবহারকারীর অ্যাড্রেস এবং চুক্তির অ্যাড্রেস উভয়ের জন্য ব্যবহৃত হয়।
          * `address payable`: বিশেষভাবে ইথার গ্রহণ করতে পারে এমন অ্যাড্রেসের জন্য ব্যবহৃত হয়।
          * উদাহরণ:
            ```solidity
            contract HelloGeeks {
                address public userAddress;
                address payable public recipientAddress;

                function setAddress(address _userAddress, address payable _recipientAddress) public {
                    userAddress = _userAddress;
                    recipientAddress = _recipientAddress;
                }
            }
            ```
  * bytes (বাইট): কাঁচা বাইনারি ডেটা সংরক্ষণের জন্য নির্দিষ্ট বা ডাইনামিক আকারের বাইট অ্যারে।
    ১.  ফিক্সড-সাইজ বাইট অ্যারে (`bytesN`):
    \* ফিক্সড-সাইজ বাইট অ্যারেগুলির একটি নির্দিষ্ট দৈর্ঘ্য থাকে, যা ১ থেকে ৩২ বাইট পর্যন্ত হতে পারে।
    \* `bytesN` নোটেশন এই অ্যারেগুলিকে প্রতিনিধিত্ব করে, যেখানে "N" দৈর্ঘ্য নির্দেশ করে একটি পূর্ণসংখ্যা।
    \* উদাহরণ:
    ` solidity contract FixedSizeBytesExample {   bytes32 public fixedData; // Fixed-size array with 32 bytes                       function setFixedData(bytes32 _data) public {   fixedData = _data;  }                       function getFixedDataLength() public view returns (uint256) { return fixedData.length; } }                        `
    \*\*\*আপনি যখন `getFixedDataLength()` কল করেন, তখন এটি `bytes32` অ্যারের নির্দিষ্ট দৈর্ঘ্য (সর্বদা ৩২ বাইট) ফেরত দেয়।
    ২.  ডাইনামিক বাইট অ্যারে (`bytes`):
    \* ডাইনামিক বাইট অ্যারেগুলির কোনো নির্দিষ্ট দৈর্ঘ্য থাকে না এবং রানটাইমে পরিবর্তন হতে পারে।
    \* এগুলি কেবল `bytes` কিওয়ার্ড দ্বারা প্রতিনিধিত্ব করা হয়।
    \* উদাহরণ:
    ` solidity contract DynamicBytesExample { bytes public dynamicData; // Dynamic array                     function setDynamicData(bytes memory _data) public {  dynamicData = _data; } }  `
    \*\*\*আমি প্রয়োজন অনুযায়ী `dynamicData` এর আকার পরিবর্তন করতে পারি। মনে রাখবেন যে ডাইনামিক অ্যারেগুলি নমনীয়, যখন আপনি সঠিক ডেটা আকার জানেন তখন ফিক্সড-সাইজ অ্যারেগুলি দক্ষতা প্রদান করে।
  * enum (এনুমেরেটেড): ব্যবহারকারী-সংজ্ঞায়িত টাইপ যা নামযুক্ত ধ্রুবক মানের একটি সেট নিয়ে গঠিত।
      * এনামগুলি ইন্টিগ্রাল ধ্রুবকগুলির জন্য নাম সরবরাহ করে, যা চুক্তিগুলিকে পড়তে এবং রক্ষণাবেক্ষণ করতে সহজ করে তোলে।
      * গণনা করা তালিকার প্রতিটি মানকে একটি এনাম বলা হয়।
      * ডিফল্টভাবে, এনামগুলি পূর্ণসংখ্যা হিসাবে প্রতিনিধিত্ব করা হয় (শূন্য থেকে শুরু করে), তবে আপনি কাস্টম মান নির্ধারণ করতে পারেন।
      * উদাহরণ:
        ```solidity
        enum Department {
            IT,
            HR,
            Finance
        }
        ```
    \*\*\*আপনি আপনার স্মার্ট চুক্তির মধ্যে ডেটা শ্রেণীবদ্ধ বা লেবেল করার একটি উপায় হিসাবে এনাম ব্যবহার করতে পারেন। মনে রাখবেন যে এনামগুলি সরাসরি ম্যাপিংয়ের কী (key) হিসাবে কাজ করতে পারে না।

২. রেফারেন্স টাইপস (REFERENCE TYPES):
এগুলি মেমরির একটি পৃথক স্থানে ডেটা সংরক্ষণ করে এবং সেই ডেটা অ্যাক্সেস করতে একটি রেফারেন্স (পয়েন্টারের মতো) ব্যবহার করে। এর মানে হল একাধিক ভেরিয়েবল একই ডেটা অবস্থানকে উল্লেখ করতে পারে। সলিডিটিতে রেফারেন্স টাইপগুলির মধ্যে রয়েছে:

  * Arrays (অ্যারে): এগুলি একই ডেটা টাইপের উপাদানগুলির অর্ডারড সংগ্রহ।
      * উদাহরণ: `pushValue()` ব্যবহার করে `dynamicArray`-এ মান যোগ করতে এবং `getValue()` ব্যবহার করে সেগুলিকে পুনরুদ্ধার করতে পারেন।
    <!-- end list -->
    ```solidity
    contract ArrayExample {
        uint256[] public dynamicArray; // Dynamic array

        function pushValue(uint256 value) public {
            dynamicArray.push(value); // Append to the array
        }

        function getValue(uint256 index) public view returns (uint256) {
            return dynamicArray[index];
        }

        function getLength() public view returns (uint256) {
            return dynamicArray.length;
        }
    }
    ```
  * Strings (স্ট্রিং):
      * UTF-8 এ এনকোড করা অক্ষরগুলির একটি অনুক্রম।
      * এটি যেকোনো ইউনিকোড অক্ষর ধারণ করতে পারে এবং এর কোনো নির্দিষ্ট আকার নেই, যার অর্থ এটি প্রয়োজন অনুযায়ী গতিশীলভাবে বৃদ্ধি পেতে পারে।
      * আপনি একটি স্ট্রিং ভেরিয়েবল এভাবে সংজ্ঞায়িত করতে পারেন: `string public myVariable = "Hello World";`
      * আপনি সরাসরি একটি মান অ্যাসাইন করে বা একটি ফাংশনে পাস করে একটি স্ট্রিং ইনিশিয়ালাইজ করতে পারেন।
      * উদাহরণ:
        ```solidity
        contract StringExample {
            string public text;              
            constructor() { text = "Hello, Solidity!"; }              
            function setText(string memory newText) public { text = newText;}
        }
        ```
  * Structs (স্ট্রাক্ট): একটি ব্যবহারকারী-সংজ্ঞায়িত ডেটা কাঠামো যা আপনাকে বিভিন্ন ধরণের সম্পর্কিত ভেরিয়েবলগুলিকে একত্রিত করতে দেয়। এটিকে একাধিক ভেরিয়েবলকে একটি একক ইউনিটে বান্ডিল করার একটি উপায় হিসাবে মনে করুন। আপনি এভাবে স্ট্রাক্ট ব্যবহার করতে পারেন:
      * একটি স্ট্রাক্ট সংজ্ঞায়িত করা:
        আপনি এর বৈশিষ্ট্য (ফিল্ড) এবং তাদের ডেটা টাইপ নির্দিষ্ট করে একটি স্ট্রাক্ট তৈরি করেন।
        ```solidity
        contract Todos {
            struct Todo {
                string text;
                bool completed;
            }
        }
        ```
      * স্ট্রাক্ট বৈশিষ্ট্যগুলি অ্যাক্সেস করা:
        আপনি ডট নোটেশন ব্যবহার করে একটি স্ট্রাক্টের পৃথক বৈশিষ্ট্যগুলি অ্যাক্সেস করতে পারেন।
          * উদাহরণ:
            ```solidity
            function get(uint256 _index) public view returns (string memory text, bool completed) {
                Todo storage todo = todos[_index];
                return (todo.text, todo.completed);
            }
            ```
  * Mappings (ম্যাপিং): এগুলি কি-ভ্যালু জোড়া যেখানে কি যেকোনো ডেটা টাইপের হতে পারে (ম্যাপিং ব্যতীত) এবং ভ্যালু যেকোনো ডেটা টাইপের হতে পারে।
      * উদাহরণ: `mapping(keyType => valueType) mappingName;`
      * সাধারণ ব্যবহার:
          * ব্যবহারকারীর অ্যাড্রেসের সাথে ডেটা যুক্ত করা (যেমন, ব্যবহারকারীর ব্যালেন্স, স্কোর সংরক্ষণ)।
          * ভোটিং সিস্টেম বাস্তবায়ন (যেমন, প্রতিটি প্রার্থীর জন্য ভোট ট্র্যাক করা)।
          * ডেটা পয়েন্টগুলির মধ্যে জটিল সম্পর্ক উপস্থাপন করা।
      * মনে রাখার বিষয়:
          * ম্যাপিংগুলি ইটারেবল নয়, অর্থাৎ আপনি অ্যারেগুলির মতো সরাসরি সেগুলির মাধ্যমে লুপ করতে পারবেন না।
          * একটি অস্তিত্বহীন কি অ্যাক্সেস করলে ভ্যালু টাইপের জন্য ডিফল্ট মান ফেরত আসে (যেমন, সংখ্যার জন্য $০$, স্ট্রিংয়ের জন্য খালি স্ট্রিং)।
          * ম্যাপিংগুলি মুছে না ফেলা পর্যন্ত ব্লকচেইনে স্থায়ীভাবে সংরক্ষিত থাকে।
  * Contract types (কন্ট্রাক্ট টাইপ): এগুলি অন্যান্য সলিডিটি চুক্তিকে নির্দেশ করে।

-----

### ০২. ভেরিয়েবল কত প্রকারের হয়? স্টেট, লোকাল এবং গ্লোবাল ভেরিয়েবলের মধ্যে পার্থক্য/সুবিধা কী কী? লোকাল ভেরিয়েবলের ডেটা কোথায় জমা হয়?

সলিডিটিতে তিন প্রকারের ভেরিয়েবল রয়েছে:

  * স্টেট ভেরিয়েবল (State Variables): যেসব ভেরিয়েবলের মান একটি চুক্তির স্টোরেজে স্থায়ীভাবে সংরক্ষণ করা হয়।
  * লোকাল ভেরিয়েবল (Local Variables): যেসব ভেরিয়েবলের মান ফাংশন এক্সিকিউট হওয়ার সময় পর্যন্ত বিদ্যমান থাকে।
  * গ্লোবাল ভেরিয়েবল (Global Variables): গ্লোবাল নেমস্পেসে বিদ্যমান বিশেষ ভেরিয়েবল যা ব্লকচেইন বা লেনদেন সম্পর্কে তথ্য পেতে ব্যবহৃত হয়।

পার্থক্য/সুবিধা:

| বৈশিষ্ট্য       | স্টেট ভেরিয়েবল                                      | লোকাল ভেরিয়েবল                                     | গ্লোবাল ভেরিয়েবল                                     |
| :--------------- | :------------------------------------------------ | :------------------------------------------------ | :------------------------------------------------ |
| জীবনকাল | চুক্তির জীবনকাল জুড়ে স্থায়ীভাবে থাকে             | ফাংশন এক্সিকিউশনের সময় পর্যন্ত বিদ্যমান থাকে      | ব্লকচেইন বা EVM-এর বর্তমান অবস্থা সম্পর্কে তথ্য দেয়  |
| সঞ্চয় স্থান | চুক্তি স্টোরেজ (ব্লকচেইনে)                            | মেমরি বা স্ট্যাক                                    | EVM-এর গ্লোবাল নেমস্পেস                            |
| প্রাপ্যতা | চুক্তির যেকোনো ফাংশন থেকে অ্যাক্সেসযোগ্য          | শুধুমাত্র যে ফাংশনে সংজ্ঞায়িত করা হয়েছে তার মধ্যে অ্যাক্সেসযোগ্য | সমস্ত ফাংশন থেকে অ্যাক্সেসযোগ্য                    |
| ব্যবহার | স্থায়ী ডেটা সংরক্ষণ, চুক্তির অবস্থা বজায় রাখা      | অস্থায়ী গণনা, ফাংশন-নির্দিষ্ট ডেটা              | ব্লক নম্বর, গ্যাস প্রাইস, প্রেরকের ঠিকানা ইত্যাদি জানা |
| পরিবর্তনযোগ্যতা | ট্রানজ্যাকশনের মাধ্যমে পরিবর্তন করা যায়             | ফাংশনের মধ্যে পরিবর্তন করা যায়                   | শুধুমাত্র পঠনযোগ্য (রিড-অনলি)                      |

লোকাল ভেরিয়েবলের ডেটা কোথায় জমা হয়?

লোকাল ভেরিয়েবলের ডেটা মেমরি (memory) অথবা স্ট্যাক (stack)-এ জমা হয়, যা ফাংশন এক্সিকিউশনের সময় পর্যন্ত বিদ্যমান থাকে এবং ফাংশন শেষ হওয়ার পর মুছে যায়।

-----

### ০৩. ভিজিবিলিটি প্রাইভেট, পাবলিক এবং ইন্টারনাল কী?

সলিডিটিতে ফাংশন এবং স্টেট ভেরিয়েবলের অ্যাক্সেস নিয়ন্ত্রণ করার জন্য ভিজিবিলিটি মডিফায়ার ব্যবহৃত হয়:

  * পাবলিক (Public): পাবলিক ভেরিয়েবলগুলি চুক্তির অভ্যন্তরে এবং বাহ্যিক চুক্তি উভয় থেকেই অ্যাক্সেসযোগ্য। সলিডিটি স্বয়ংক্রিয়ভাবে পাবলিক স্টেট ভেরিয়েবলের জন্য একটি গেটার ফাংশন তৈরি করে।
  * প্রাইভেট (Private): প্রাইভেট ভেরিয়েবলগুলি শুধুমাত্র সেই চুক্তির মধ্যে অ্যাক্সেসযোগ্য যেখানে সেগুলি সংজ্ঞায়িত করা হয়েছে। এগুলি ডিরাইভড চুক্তি বা বাহ্যিক চুক্তি থেকে লুকানো থাকে।
  * ইন্টারনাল (Internal): ইন্টারনাল ভেরিয়েবলগুলি সেই চুক্তির মধ্যে অ্যাক্সেসযোগ্য যেখানে সেগুলি সংজ্ঞায়িত করা হয়েছে এবং ডিরাইভড চুক্তি থেকেও অ্যাক্সেসযোগ্য। তবে, এগুলি বাহ্যিক চুক্তি থেকে অ্যাক্সেসযোগ্য নয়।
  * এক্সটারনাল (External): এক্সটারনাল ফাংশনগুলি শুধুমাত্র বাহ্যিকভাবে (চুক্তির বাইরে থেকে) কল করা যায়। এগুলি চুক্তির মধ্যে থেকেই অ্যাক্সেস করা যায় না।

-----

### ০৪. অ্যারে কী এবং এটি কিভাবে কাজ করে? অ্যারে পুশ কিভাবে সংজ্ঞায়িত করা হয়?

অ্যারে (Array): অ্যারে হলো একই ডেটা টাইপের উপাদানগুলির একটি অর্ডারড সংগ্রহ। সলিডিটিতে দু'ধরনের অ্যারে আছে:

  * ফিক্সড-সাইজ অ্যারে (Fixed-size arrays): নির্দিষ্ট আকার সহ ঘোষিত হয়।
    ```solidity
    uint[5] fixedArray;  // 5টি আনসাইনড ইন্টিজারের একটি অ্যারে
    ```
  * ডাইনামিক অ্যারে (Dynamic arrays): নির্দিষ্ট আকার ছাড়াই ঘোষিত হয়।
    ```solidity
    uint[] dynamicArray;  // আনসাইনড ইন্টিজারের একটি ডাইনামিক অ্যারে
    ```

অ্যারে পুশ (Array Push) কিভাবে কাজ করে?

ডাইনামিক অ্যারেতে নতুন উপাদান যোগ করতে `push()` ফাংশন ব্যবহার করা হয়। এটি অ্যারের শেষে একটি নতুন উপাদান যোগ করে।

```solidity
dynamicArray.push(1);  // অ্যারেতে 1 যোগ করে
dynamicArray.push(2);  // অ্যারেতে 2 যোগ করে
```

-----

### ০৫. IF...ELSE স্টেটমেন্ট কিভাবে কাজ করে? টেনারি অপারেটর কিভাবে সংজ্ঞায়িত করা হয়?

IF...ELSE স্টেটমেন্ট:
`if...else` স্টেটমেন্ট একটি শর্তের উপর ভিত্তি করে কোড ব্লক এক্সিকিউট করতে ব্যবহৃত হয়।

```solidity
contract IfElseExample {
    function checkValue(uint value) public pure returns (string memory) {
        if (value < 10) {
            return "Value is less than 10"; // যদি value 10 এর কম হয়
        } else if (value == 10) {
            return "Value is 10"; // যদি value 10 এর সমান হয়
        } else {
            return "Value is greater than 10"; // অন্যথায় (value 10 এর বেশি হয়)
        }
    }
}
```

-----

টেনারি অপারেটর (Ternary Operator):
টেনারি অপারেটর `(শর্ত ? এক্সপ্রেশন_১ : এক্সপ্রেশন_২)` একটি শর্তের উপর ভিত্তি করে দুটি মানের মধ্যে একটি ফেরত দেয়। যদি শর্ত `true` হয়, তাহলে `এক্সপ্রেশন_১` ফেরত দেওয়া হয়; অন্যথায় `এক্সপ্রেশন_২` ফেরত দেওয়া হয়।

```solidity
contract TernaryOperatorExample {
    function getValue(uint value) public pure returns (string memory) {
        return value < 10 ? "Less than 10" : "10 or greater";
    }
}
```

-----

### ০৬. লুপ: FOR

FOR লুপ:
`for` লুপ একটি নির্দিষ্ট সংখ্যক বার একটি কোড ব্লক পুনরাবৃত্তি করতে ব্যবহৃত হয়।

```solidity
contract ForLoopExample {
    function sumOfNumbers(uint n) public pure returns (uint) {
        uint sum = 0;
        for (uint i = 1; i <= n; i++) { // i=1 থেকে n পর্যন্ত লুপ চলে
            sum += i; // প্রতিটি পুনরাবৃত্তিতে sum এর সাথে i যোগ হয়
        }
        return sum;
    }
}
```

-----

### ০৭. CONSTRUCTOR() কিভাবে সংজ্ঞায়িত করা হয়?

CONSTRUCTOR():
কন্সট্রাক্টর হলো একটি বিশেষ ফাংশন যা চুক্তি স্থাপন করার সময় (deploy) শুধুমাত্র একবার এক্সিকিউট হয়। এটি সাধারণত চুক্তির প্রাথমিক স্টেট সেট আপ করতে ব্যবহৃত হয়।

```solidity
contract Token {
    string public name; // স্টেট ভেরিয়েবল
    constructor(string memory _name) { // কন্সট্রাক্টর সংজ্ঞায়িত করা
        name = _name; // নাম সেট করা
    }
}
```

-----

### ০৮. একাধিক মান কিভাবে ফেরত দেওয়া হয়?

সলিডিটিতে একাধিক মান ফেরত দেওয়ার বিভিন্ন উপায় আছে, যার মধ্যে স্ট্রাক্ট ব্যবহার করা একটি জনপ্রিয় পদ্ধতি:

```solidity
contract StructReturnExample {

    struct Person {     // একটি স্ট্রাক্ট সংজ্ঞায়িত করা
        string name;
        uint age;
    }

    function getPerson() public pure returns (Person memory) {     // একটি ফাংশন যা একটি স্ট্রাক্ট ফেরত দেয়
        return Person("Alice", 30);
    }

    function useReturnedStruct() public pure returns (string memory, uint) {      // একটি ফাংশন যা ফেরত দেওয়া স্ট্রাক্ট ব্যবহার করে
        Person memory person = getPerson();
        return (person.name, person.age);
    }
}
```

এখানে, `getPerson()` ফাংশনটি একটি `Person` স্ট্রাক্ট ফেরত দিচ্ছে, এবং `useReturnedStruct()` ফাংশনটি সেই স্ট্রাক্ট থেকে নাম ও বয়স আলাদাভাবে ব্যবহার ও ফেরত দিচ্ছে।

-----

### ০৯. রিকোয়ার, রিভার্ট এবং অ্যাসার্ট এর মধ্যে পার্থক্য কী?

এগুলি সবই সলিডিটিতে ত্রুটি পরিচালনার জন্য ব্যবহৃত হয়, তবে তাদের ব্যবহারের ক্ষেত্র এবং প্রভাব ভিন্ন:

  * `require` ফাংশন:

      * কাজ: এমন শর্তাবলী প্রয়োগ করে যা ফাংশনটি এগিয়ে যাওয়ার জন্য অবশ্যই সত্য হতে হবে।
      * আচরণ:
          * যদি শর্ত সত্য হয়, ফাংশনটি এক্সিকিউশন চালিয়ে যায়।
          * যদি শর্ত মিথ্যা হয়, লেনদেনটি রিভার্ট (revert) হয়। এর মানে হল ফাংশনের মধ্যে করা যেকোনো স্টেট পরিবর্তন পূর্বাবস্থায় ফিরে আসে এবং ব্যবহারকারী সেই পর্যন্ত ব্যবহৃত গ্যাসের জন্য অর্থ ফেরত পায়।
          * ডিবাগিংয়ের উদ্দেশ্যে একটি ত্রুটি বার্তা সরবরাহ করে।
      * ব্যবহারের ক্ষেত্র:
          * ইনপুট ভ্যালিডেশন (যেমন, ধনাত্মক মান নিশ্চিত করা)।
          * স্টেট ইনভ্যারিয়েন্টস প্রয়োগ করা (যেমন, স্থানান্তরের আগে ব্যবহারকারীর ব্যালেন্স চেক করা)।
          * অ্যাক্সেস কন্ট্রোল চেক (যেমন, প্রেরকের ঠিকানা যাচাই করা)।
      * উদাহরণ:
        ```solidity
        uint public value;
        function setValue(uint _newValue) public {
            // নিশ্চিত করা যে নতুন মান 0 এর চেয়ে বড়
            require(_newValue > 0, "New value must be greater than 0");
            value = _newValue;
        }
        ```

  * `revert`:

      * কাজ: এটি একটি সাধারণ-উদ্দেশ্যের ত্রুটি পরিচালনার জন্য ব্যবহার করা যেতে পারে।
      * আচরণ: যখন `revert()` কল করা হয়, তখন বর্তমান এক্সিকিউশন অবিলম্বে বন্ধ হয়ে যায় এবং সমস্ত স্টেট পরিবর্তন পূর্বাবস্থায় ফিরে আসে, অনেকটা `require` এর মিথ্যা শর্তের মতো। আপনি একটি ঐচ্ছিক স্ট্রিং বার্তা পাস করতে পারেন।
      * ব্যবহারের ক্ষেত্র: যখন একটি নির্দিষ্ট ত্রুটি ঘটে যা কোনো `require` শর্তের সাথে সরাসরি সম্পর্কিত নয়, বা আরও কাস্টম ত্রুটি হ্যান্ডলিং প্রয়োজন।
      * উদাহরণ:
        ```solidity
        if (balance[msg.sender] < amount) {
            revert("Insufficient balance"); // পর্যাপ্ত ব্যালেন্স না থাকলে রিভার্ট করুন
        }
        ```

  * `assert`:

      * কাজ: অভ্যন্তরীণ ত্রুটি পরীক্ষা এবং অনুমানগুলির জন্য ব্যবহৃত হয় যা একটি সু-লিখিত চুক্তিতে কখনই মিথ্যা হওয়া উচিত নয়।
      * আচরণ: যদি `assert()` এর শর্ত মিথ্যা হয়, তাহলে EVM একটি "ইনভ্যালিড অপকোড" ত্রুটি তৈরি করে এবং সমস্ত গ্যাস খরচ করে ফেলে, কোনো গ্যাস ফেরত দেয় না। এটি একটি গুরুতর ত্রুটি নির্দেশ করে যা প্রোগ্রামিং লজিকের ত্রুটির কারণে হয়েছে।
      * ব্যবহারের ক্ষেত্র: ডেভেলপারদের জন্য অভ্যন্তরীণ চেক এবং চুক্তি ইনভ্যারিয়েন্টস নিশ্চিত করতে, যা একটি বাগ নির্দেশ করে যদি সেগুলি লঙ্ঘিত হয়।
      * উদাহরণ: (সাধারণত জটিল লজিকের সাথে ব্যবহৃত হয় যেখানে একটি শর্ত সর্বদা সত্য হওয়া উচিত)
        ```solidity
        // উদাহরণস্বরূপ, একটি ইনভ্যারিয়েন্ট চেক
        assert(totalSuppy == balance[owner] + balance[user]);
        ```

-----

### ১০. সলিডিটিতে `view` এবং `pure` ফাংশনের মধ্যে পার্থক্য কী?

`view` ফাংশন:
`view` ফাংশনগুলি যখন চুক্তির স্টোরেজ (স্টেট ভেরিয়েবল) থেকে ডেটা পড়তে হয় কিন্তু এটি পরিবর্তন করার প্রয়োজন হয় না (যেমন, একজন ব্যবহারকারীর ব্যালেন্স পাওয়া)।

  * `view` ফাংশনগুলি চুক্তির স্টেট ভেরিয়েবল থেকে ডেটা পড়তে পারে, কিন্তু সেগুলিতে কোনো পরিবর্তন করতে পারে না।

  * এগুলি গ্যাস খরচ করে না যখন এগুলি একটি বাহ্যিক ট্রানজ্যাকশন ছাড়াই কেবল ডেটা পড়ার জন্য কল করা হয়।

  * উদাহরণ:

    ```solidity
    contract Test {
        uint num1 = 2;
        uint num2 = 4;

        function getResult() public view returns (uint product, uint sum) {
            product = num1 * num2; // স্টেট ভেরিয়েবল num1 এবং num2 পড়ে গণনা করা হচ্ছে
            sum = num1 + num2;
        }
    }
    ```

    এই উদাহরণে, `getResult()` দুটি আনসাইনড ইন্টিজারের গুণফল এবং যোগফল গণনা করে কোনো স্টেট পরিবর্তন না করেই।

`pure` ফাংশন:
`pure` ফাংশনগুলি এমন গণনার জন্য ব্যবহৃত হয় যা শুধুমাত্র প্রদত্ত ইনপুটগুলির উপর নির্ভর করে এবং ব্লকচেইনের সাথে মোটেও ইন্টারঅ্যাক্ট করে না (যেমন, গাণিতিক অপারেশন বা স্ট্রিং ম্যানিপুলেশন)।

  * `pure` ফাংশনগুলি চুক্তির স্টেট ভেরিয়েবল পড়তে বা পরিবর্তন করতে পারে না।

  * এগুলি কেবলমাত্র তাদের আর্গুমেন্ট এবং ফাংশনের মধ্যে সংজ্ঞায়িত স্থানীয় ভেরিয়েবলগুলির উপর ভিত্তি করে কাজ করে।

  * এগুলি গ্যাস খরচ করে না যখন এগুলি একটি বাহ্যিক ট্রানজ্যাকশন ছাড়াই কেবল গণনা করার জন্য কল করা হয়।

  * উদাহরণ:

    ```solidity
    contract Test {
        function getResult() public pure returns (uint product, uint sum) {
            uint a = 1; // স্থানীয় ভেরিয়েবল
            uint b = 2; // স্থানীয় ভেরিয়েবল
            product = a * b; // স্থানীয় ভেরিয়েবল ব্যবহার করে গণনা করা হচ্ছে
            sum = a + b;
        }
    }
    ```

    এখানে, `getResult()` শুধুমাত্র স্থানীয় ভেরিয়েবলের উপর ভিত্তি করে গণনা করে, যা এটিকে একটি `pure` ফাংশন করে তোলে।

-----

আপনার যদি সলিডিটির অন্য কোনো প্রশ্ন থাকে তবে জিজ্ঞাসা করতে পারেন।


















01. How many Data Types are there in Solidity? What are the differences among them?
02. How many types of Variables are there? Differences/Advantages among State, Local, and Global Varibale? Where data of local variables are stored?
03. What is Visibility Private, Public and Internal?

04. What is Array and how it works? how to define Array Push?
05. How does IF...ELSE statement work? How to define a Tenary operator?
06. Loop: FOR

07. How to define CONSTRUCT() 
08. How to return multiple values?
09. Difference among Required, Revert, and Assert?

10. Difference between views and pure in solidity??


=================== 01. How many Data Types are there in Solidity? What are the differences among them? =============================

VALUE TYPES:
------------
store their data directly in the memory they own. This means that whenever a value type variable is used in a function argument or assignment,
a copy of the variable is created. There are eight basic value types in Solidity:

int           -Signed integers: These can store both positive and negative whole numbers.(e.g., int8, int256)
                int256(default) store	32bytes of data and  Range	-2^255 to 2^255-1.
unit          -Unsigned integers: These can only store non-negative whole numbers(including 0) (e.g., uint8, uint256) .
               -uint256 can hold values between 0 and (2^256 - 1),  which is a very large number (approximately 1.1579 x 10^77 in decimal).
bool          -These can only be true or false (e.g., 0 or 1).

address       -These represent a 20-byte Ethereum address.(use to Sending and Receiving Ether, Interacting with Other Contracts, Storing Account Information)
                -Addresses are case-sensitive (e.g., 0xAbCdEf1234567890AbCdEf1234567890 is different from 0xabcdEf1234567890aBcDeF1234567890).
                -In Solidity, there are two address types:
                --address: Used for both user addresses and contract addresses.
               --address payable: Specifically used for addresses that can receive Ether.
                >>Example:
                  contract HelloGeeks {
                            address public userAddress;
                            address payable public recipientAddress;
                        
                            function setAddress(address _userAddress, address payable _recipientAddress) public {
                                userAddress = _userAddress;
                                recipientAddress = _recipientAddress;
                            }
                        }

bytes         -Fixed or dynamically sized byte arrays to store raw binary data.
                1.Fixed-Size Byte Arrays (bytesN):
                      Fixed-size byte arrays have a specified length, ranging from 1 to 32 bytes.
                      The notation “bytesN” represents these arrays, where “N” is an integer indicating the length.
                  >>Example:                      
                      contract FixedSizeBytesExample {   bytes32 public fixedData; // Fixed-size array with 32 bytes                      
                          function setFixedData(bytes32 _data) public {   fixedData = _data;  }                      
                          function getFixedDataLength() public view returns (uint256) { return fixedData.length; }
                      }                      
                      ***When you call getFixedDataLength(), it returns the fixed length of the bytes32 array (always 32 bytes).
                2. Dynamic Byte Arrays:
                    --Dynamic byte arrays do not have a fixed length and can change during runtime.
                    --They are simply represented by the “bytes” keyword.
                  >>Example:                   
                    contract DynamicBytesExample {
                        bytes public dynamicData; // Dynamic array                    
                        function setDynamicData(bytes memory _data) public {  dynamicData = _data; }
                    }

                ***I can modify the size of dynamicData as needed. 
                   Remember that dynamic arrays are flexible, while fixed-size arrays provide efficiency when you know the exact data size.

enum(enumerated) -user-defined types that consist of a set of named constant values.
                >Enums provide names for integral constants, making contracts easier to read and maintain.
                >Each value in the enumerated list is called an enum.
                >By default, enums are represented as integers (starting from zero), but you can assign custom values.
              >>Example:
                  enum Department {
                    IT,
                    HR,
                    Finance
                 }
                
     **You can use enums as a way to categorize or label data within your smart contracts. 
       Remember that enums cannot directly serve as keys in mappings


REFERENCE TYPES:
----------------
store data in a separate location in memory and use a reference (like a pointer) to access that data. 
This means that multiple variables can refer to the same data location.expand_more Reference types in Solidity include:

Arrays: These are ordered collections of elements of the same data type.
        Example: can add values to dynamicArray using pushValue() and retrieve them using getValue().
        contract ArrayExample {
              uint256[] public dynamicArray; // Dynamic array
          
              function pushValue(uint256 value) public {
                  dynamicArray.push(value); // Append to the array
              }
          
              function getValue(uint256 index) public view returns (uint256) {
                  return dynamicArray[index];
              }
          
              function getLength() public view returns (uint256) {
                  return dynamicArray.length;
              }
          }


Strings:  --Is a sequence of characters encoded in UTF-8.
          --It can contain any Unicode character and has no fixed size, meaning it can grow dynamically as needed.
          --I can define a string variable like this: string public myVariable = "Hello World";
          --I can initialize a string by directly assigning a value or passing it to a function.
            >>Example:
              contract StringExample {
                  string public text;              
                  constructor() { text = "Hello, Solidity!"; }              
                  function setText(string memory newText) public { text = newText;}
              }

Structs: is a user-defined data structure that allows you to group together related variables of different types. 
         -Think of it as a way to bundle multiple variables into a single unit. Here’s how you can use structs:
         -Defining a Struct:
          ------------------
        - I create a struct by specifying its properties (fields) and their data types.
                  contract Todos {
                      struct Todo {
                          string text;
                          bool completed;
                      }
                  }

                  >>Accessing Struct Properties:
                    ----------------------------
                  I can access individual properties of a struct using dot notation.
                  >>Example:
                  function get(uint256 _index) public view returns (string memory text, bool completed) {
                      Todo storage todo = todos[_index];
                      return (todo.text, todo.completed);
                  }

Mappings: These are key-value pairs where the key can be of any data type (except for mappings) and the value can be of any data type.
          >>Example: mapping(keyType => valueType) mappingName;
           >>Common use cases:
            Associating data with user addresses (e.g., storing user balances, scores).
            Implementing voting systems (e.g., tracking votes for each candidate).
            Representing complex relationships between data points.
            
          >>Things to remember:            
            Mappings are not iterable, meaning you can't loop through them directly like arrays.
            Accessing a non-existent key returns the default value for the value type (e.g., 0 for numbers, empty string for strings).
            Mappings are stored permanently on the blockchain unless deleted.

Contract types: These refer to other Solidity contracts.

=================== 02. How many types of Variables are there? Differences/Advantages among State, Local, and Global Varibale? Where data of local variables are stored? =============================
State Variables − Variables whose values are permanently stored in a contract storage
Local Variables − Variables whose values are present till function is executing.
Global Variables − Special variables exists in the global namespace used to get information about the 


=================== 03. What is Visibility Private, Public and Internal? ==========================================
Public: Public variables are accessible both within the contract and from external contracts. Solidity automatically generates a getter function for public state variables.
Private: Private variables are only accessible within the contract where they are defined. They remain hidden from derived contracts or external contracts.
Internal: Internal variables are accessible within the contract where they are defined and also from derived contracts. However, they are not accessible from external contracts.
External: External functions can only be called externally (from outside the contract). They cannot be accessed within the contract itself.

=================== 04. What is Array and how it work? how to define Array Push? =============================
Fixed-size arrays: Declared with a specific size.
uint[5] fixedArray;  // An array of 5 unsigned integers

Dynamic arrays: Declared without a specific size.
uint[] dynamicArray;  // A dynamic array of unsigned integers

dynamicArray.push(1);  // Adds 1 to the array
dynamicArray.push(2);  // Adds 2 to the array




=================== 05. How does IF...ELSE statement work? How to define a Tenary operator? =============================
contract IfElseExample {
    function checkValue(uint value) public pure returns (string memory) {
        if (value < 10) {
            return "Value is less than 10";
        } else if (value == 10) {
            return "Value is 10";
        } else {
            return "Value is greater than 10";
        }
    }
}
---
contract TernaryOperatorExample {
    function getValue(uint value) public pure returns (string memory) {
        return value < 10 ? "Less than 10" : "10 or greater";
    }
}
=================== 06. FOR Loop =============================
contract ForLoopExample {
    function sumOfNumbers(uint n) public pure returns (uint) {
        uint sum = 0;
        for (uint i = 1; i <= n; i++) {
            sum += i;
        }
        return sum;
    }
}

=================== 07. How to define CONSTRUCT() ==========================================================
contract Token {
    string public name; // State variables
    constructor(string memory _name) {
        name = _name;
    }
}
=================== 08. How to return multiple values? ============================================
contract StructReturnExample {

    struct Person {     // Define a struct
        string name;
        uint age;
    }

    function getPerson() public pure returns (Person memory) {     // Function that returns a struct
        return Person("Alice", 30);
    }

    function useReturnedStruct() public pure returns (string memory, uint) {      // Function that uses the returned struct
        Person memory person = getPerson();
        return (person.name, person.age);
    }
=================== 09. Difference among Required, Revert, and Assert? =============================
Require Function: Enforces conditions that must be true for the function to proceed.
  >>Behavior:
    If the condition is true, the function continues execution.
    If the condition is false, the transaction is reverted. This means any state changes made within the function are undone, and the user gets refunded for the gas used up to that point.
    Provides an error message for debugging purposes.
  >>Use Cases:
    Input validation (e.g., ensuring positive values)
    Enforcing state invariants (e.g., user balance check before transfer)
    Access control checks (e.g., verifying sender address)
            Example:
               uint public value;
              function setValue(uint _newValue) public {
                // Enforce that the new value is greater than 0
                require(_newValue > 0, "New value must be greater than 0");
                value = _newValue;
              }

Revert: Can be used for general-purpose error handling.
        if (balance[msg.sender] < amount) {  revert("Insufficient balance"); }

Assert: Used for internal error checking and assumptions that should never be false in a well-written contract.

=================== 10. Difference between views and pure Function in solidity? =============================
VIEW: functions when you need to read data from the contract's storage(State Variables, Modifiers or Gas Consumption) without modifying it (e.g., getting a user's balance).
     -- In this example, getResult() calculates the product and sum of two unsigned integers without modifying any state
            contract Test {
          uint num1 = 2;
          uint num2 = 4;
      
          function getResult() public view returns (uint product, uint sum) {
              product = num1 * num2;
              sum = num1 + num2;
          }
      }
      
PURE: functions for calculations that only rely on the provided inputs and don't interact with the blockchain at all (e.g., mathematical operations or string manipulation).
      --Here, getResult() performs calculations based solely on local variables, making it a pure function
      contract Test {
    function getResult() public pure returns (uint product, uint sum) {
        uint a = 1;
        uint b = 2;
        product = a * b;
        sum = a + b;
    }
}





--

